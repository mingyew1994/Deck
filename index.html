<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Deck Box — Tap to Manage (Firebase)</title>
  <style>
    :root { --bg:#0b0f14; --card:#121922; --text:#ecf2f8; --muted:#9fb3c8; --accent:#57b2ff; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:linear-gradient(180deg,#0b0f14,#0b0f14 60%,#0e141b); color:var(--text); }
    .wrap { max-width: 1040px; margin: 0 auto; padding: 20px; }
    .card { background: var(--card); border:1px solid #1d2633; border-radius: 16px; padding: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.25); }
    h1 { font-size: 1.6rem; margin: 0 0 4px; letter-spacing:.2px; }
    .sub { color: var(--muted); margin-bottom: 14px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; }
    input, textarea, button, select {
      background:#0c1219; color:var(--text); border:1px solid #1d2633; border-radius:12px; padding:12px 14px; font-size:15px;
    }
    input, select, button { height:44px; }
    input::placeholder { color:#5f748a; }
    button { cursor:pointer; font-weight:600; }
    .btn { background:#101925; }
    .btn:hover { background:#132033; }
    .btn.primary { background:var(--accent); color:#00121f; border-color:transparent; }
    .btn.primary:hover { filter:brightness(1.05); }
    .grid { display:grid; grid-template-columns: 1fr; gap:12px; }
    @media(min-width:1000px){ .grid { grid-template-columns: 3fr 2fr; } }
    ul { list-style:none; padding:0; margin:0; }
    li { display:flex; justify-content:space-between; align-items:center; padding:10px 12px; border:1px solid #1d2633; border-radius:12px; background:#0d141c; margin-bottom:8px; }
    .pill { font:600 12px/1.6 system-ui; padding:4px 8px; border-radius:999px; background:#0c1924; border:1px solid #223246; color:#9cc9f5; }
    .muted { color:var(--muted); font-size:13px; }
    .spacer { height:6px; }
    .footer { text-align:center; color:#6a7f93; font-size:12px; margin-top:14px; }
    .hidden { display:none; }

    .result { display:flex; gap:10px; align-items:center; }
    .result img { width:56px; height:auto; border-radius:10px; border:1px solid #203040; background:#0b1320; }

    /* Deck grid layout with thumbnails */
    .deck-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap:12px; }
    .deck-grid li { flex-direction: column; align-items:stretch; margin:0; }
    .deck-grid .thumb { width:100%; height:auto; max-height:260px; object-fit:cover; border-radius:12px; margin:0 0 8px 0; border:1px solid #203040; background:#0b1320; }
    .deck-grid .title { font-weight:600; display:flex; justify-content:space-between; align-items:center; gap:8px; }
    .deck-grid .controls { display:flex; gap:8px; margin-top:8px; }
  </style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>Deck Box</h1>
    <div class="sub">Deck: <span id="deckSlug" class="pill">loading…</span></div>

    <div id="noDeck" class="card" style="margin-bottom:12px;">
      <div class="row" style="align-items:center; justify-content:space-between; gap:12px;">
        <div>
          <strong>No deck loaded.</strong>
          <div class="muted">Create a new deck (generates a secret link), or paste an existing deck ID.</div>
        </div>
        <div class="row">
          <button id="createBtn" class="btn primary">Create new deck</button>
        </div>
      </div>
      <div class="spacer"></div>
      <div class="row">
        <input id="existingId" placeholder="Paste existing deck UUID (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)" style="flex:1; min-width:260px;" />
        <button id="openExistingBtn" class="btn">Open</button>
      </div>
    </div>

    <div class="grid" id="app" class="hidden">
      <div class="stack">
        <div class="row">
          <input id="cardId" placeholder="Card ID (e.g., sv4-123 or full tcg.id)" style="flex:2; min-width:140px" />
          <input id="cardName" placeholder="Name (optional)" style="flex:3; min-width:160px" />
          <input id="qty" type="number" min="1" value="1" style="width:90px" title="Quantity" />
        </div>
        <div class="row">
          <button id="addBtn" class="btn primary">Add / Increase</button>
          <button id="decreaseBtn" class="btn">Decrease</button>
          <button id="removeBtn" class="btn">Remove card</button>
          <button id="checkBtn" class="btn">Check in deck?</button>
        </div>

        <div class="card">
          <strong>Search Pokémon cards</strong>
          <div class="spacer"></div>
          <div class="row">
            <input id="searchName" placeholder="Type card name (e.g., Charizard)" style="flex:1; min-width:240px" />
            <button id="searchBtn" class="btn">Search</button>
          </div>
          <div class="spacer"></div>
          <ul id="results"></ul>
        </div>

        <div class="card">
          <div class="row" style="align-items:center; justify-content:space-between;">
            <strong>Cards in Deck</strong>
            <span class="muted" id="countLabel">0 cards</span>
          </div>
          <div class="spacer"></div>
          <ul id="list" class="deck-grid"></ul>
        </div>
      </div>

      <div class="stack">
        <div class="card">
          <strong>Deck Link</strong>
          <div class="spacer"></div>
          <div class="row">
            <input id="deckUrl" readonly style="flex:1" />
            <button id="copyUrlBtn" class="btn">Copy URL</button>
          </div>
          <div class="spacer"></div>
          <div class="muted">Write this URL to your NFC tag. Anyone with this link can view and edit this deck.</div>
        </div>

        <div class="card">
          <strong>Import / Export</strong>
          <div class="spacer"></div>
          <div class="row">
            <button id="exportBtn" class="btn">Export JSON</button>
            <button id="copyBtn" class="btn">Copy</button>
            <button id="downloadBtn" class="btn">Download</button>
          </div>
          <div class="spacer"></div>
          <textarea id="jsonArea" rows="8" placeholder='Paste JSON here to import'></textarea>
          <div class="spacer"></div>
          <div class="row">
            <button id="importBtn" class="btn">Import JSON</button>
            <button id="clearBtn" class="btn">Clear deck</button>
          </div>
        </div>

        <div class="card">
          <strong>Notes</strong>
          <div class="spacer"></div>
          <ul class="muted">
            <li>Search runs only on click/Enter and cancels previous requests.</li>
            <li>Deck shows thumbnails; images auto-backfill and are cached.</li>
            <li>Anyone with this URL can edit (no login). Use unique, unguessable UUIDs.</li>
          </ul>
        </div>
      </div>
    </div>

    <div class="footer">v1.4 — Click/Enter search + cancel • Thumbnails with backfill • Quantities.</div>
  </div>
</div>

<!-- Firebase (Modular SDK) -->
<script type="module">
  // ====== Firebase SDK imports ======
  import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js';
  import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, serverTimestamp, enableIndexedDbPersistence } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js';

  // ====== Your Firebase config ======
  const firebaseConfig = {
    apiKey: "AIzaSyCxmKPfglneWP0PbzFumT9Az24M9k4ZuJI",
    authDomain: "decksmiths-2025.firebaseapp.com",
    projectId: "decksmiths-2025",
    storageBucket: "decksmiths-2025.firebasestorage.app",
    messagingSenderId: "487112789478",
    appId: "1:487112789478:web:5b8be16aea20c90a199a27",
    measurementId: "G-GFBVJ4BGDT"
  };

  // ====== App init ======
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  try { enableIndexedDbPersistence(db); } catch (_) {}

  // ====== DOM helpers ======
  const $ = sel => document.querySelector(sel);
  const byId = id => document.getElementById(id);
  const slugSpan = byId('deckSlug');
  const deckUrlInput = byId('deckUrl');

  // ====== Routing / Slug ======
  const params = new URLSearchParams(location.search);
  let slug = (params.get('deck')||'').trim();

  function setSlug(newSlug, push=true){
    slug = newSlug;
    slugSpan.textContent = slug || '—';
    if (slug) {
      const url = `${location.origin}${location.pathname}?deck=${encodeURIComponent(slug)}`;
      deckUrlInput.value = url;
      if (push) history.replaceState(null, '', url);
      $('#noDeck').classList.add('hidden');
      $('#app').classList.remove('hidden');
    } else {
      $('#noDeck').classList.remove('hidden');
      $('#app').classList.add('hidden');
    }
  }

  setSlug(slug, false);

  // ====== Firestore helpers ======
  const deckRef = () => doc(db, 'decks', slug);
  let unsub = null;          // snapshot unsubscribe
  let currentDeck = null;    // last snapshot state

  async function ensureDeckExists(){
    if (!slug) return;
    const snap = await getDoc(deckRef());
    if (!snap.exists()) {
      await setDoc(deckRef(), { cards: [], updated_at: serverTimestamp() });
    }
  }

  async function subscribe(){
    if (!slug) return;
    if (unsub) { unsub(); unsub=null; }
    await ensureDeckExists();
    unsub = onSnapshot(deckRef(), (snap)=>{
      if (snap.exists()) {
        currentDeck = snap.data();
        render();
      }
    });
  }

  function normalizeId(s){ return (s||'').trim().toLowerCase(); }
  function fmtCount(n){ return `${n} card${n===1?'':'s'}`; }
  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[m])); }

  // ====== UI Render (grid + thumbnails) ======
  function render(){
    const list = byId('list');
    list.innerHTML = '';
    const cards = (currentDeck?.cards)||[];
    const total = cards.reduce((sum,c)=> sum + Number(c.qty||1), 0);
    byId('countLabel').textContent = `${fmtCount(cards.length)} • ${total} total`;
    cards.forEach(c=>{
      const li = document.createElement('li');

      const img = document.createElement('img'); img.className='thumb'; img.loading='lazy'; img.decoding='async'; img.alt=c.name||c.id;
      if (c.image) { img.src=c.image; } else { img.style.display='none'; }
      img.onerror = ()=>{ img.style.display='none'; };

      const title = document.createElement('div'); title.className='title';
      title.innerHTML = `<span><strong>${c.name||c.id}</strong>${c.name?` <span class=\"muted\">(${c.id})</span>`:''}</span> <span class=\"pill\">x${c.qty||1}</span>`;

      const added = document.createElement('div'); added.className='muted';
      added.textContent = `Added ${new Date(c.added_at||Date.now()).toLocaleString()}`;

      const controls = document.createElement('div'); controls.className='controls';
      const inc = document.createElement('button'); inc.textContent = '+1'; inc.className='btn'; inc.onclick=()=> changeQty(c.id, +1);
      const dec = document.createElement('button'); dec.textContent = '-1'; dec.className='btn'; dec.onclick=()=> changeQty(c.id, -1);
      const del = document.createElement('button'); del.textContent = 'Remove'; del.className = 'btn'; del.onclick = ()=> removeCard(c.id);
      controls.appendChild(inc); controls.appendChild(dec); controls.appendChild(del);

      li.appendChild(img);
      li.appendChild(title);
      li.appendChild(added);
      li.appendChild(controls);
      list.appendChild(li);
    });

    // Backfill thumbnails that are missing (async)
    debouncedBackfill();
  }

  // ====== Pokémon TCG helpers (search + images) ======
  const POKETCG_KEY = '9293fbfc-d890-4d06-8ca8-88380d376826';
  const searchCache = new Map(); // name -> results
  const idCache = new Map();     // id -> full card json
  const imageCache = new Map();  // id -> image url

  async function fetchCardById(id){
    const norm = (id||'').toLowerCase();
    if (idCache.has(norm)) return idCache.get(norm);
    const headers = POKETCG_KEY ? { 'X-Api-Key': POKETCG_KEY } : {};
    const r = await fetch(`https://api.pokemontcg.io/v2/cards/${encodeURIComponent(norm)}`, { headers });
    if (!r.ok) return null;
    const j = await r.json();
    const card = j.data || null; if(card) idCache.set(norm, card); return card;
  }

  function parseSetNumFromId(id){
    const m = String(id||'').toLowerCase().match(/^([a-z0-9]+)-([a-z0-9]+)$/);
    if (!m) return null; return { set:m[1], num:m[2] };
  }
  const cdnUrl = (set,num)=>`https://images.pokemontcg.io/${set}/${num}.png`;
  async function urlExists(url){ try { const r = await fetch(url, { method:'HEAD' }); return r.ok; } catch { return false; } }

  async function resolveImageForCardId(id){
    const norm = (id||'').toLowerCase();
    if (imageCache.has(norm)) return imageCache.get(norm);

    // 1) Try API by ID
    const viaId = await fetchCardById(norm);
    if (viaId?.images?.small){ imageCache.set(norm, viaId.images.small); return viaId.images.small; }

    // 2) Try set+number → CDN then API query
    const sn = parseSetNumFromId(norm);
    if (sn){
      const fast = cdnUrl(sn.set, sn.num);
      if (await urlExists(fast)) { imageCache.set(norm, fast); return fast; }
      const headers = POKETCG_KEY ? { 'X-Api-Key': POKETCG_KEY } : {};
      const q = encodeURIComponent(`set.id:${sn.set} number:${sn.num}`);
      const r = await fetch(`https://api.pokemontcg.io/v2/cards?q=${q}&pageSize=1`, { headers });
      if (r.ok){ const j = await r.json(); const c = (j.data||[])[0]; if (c?.images?.small){ imageCache.set(norm, c.images.small); return c.images.small; } }
    }

    imageCache.set(norm, '');
    return '';
  }

  // ====== Image backfill after render ======
  const debouncedBackfill = debounce(async ()=>{
    const cards = (currentDeck?.cards)||[];
    const next = [...cards];
    let changed = false;
    for (let i=0;i<next.length;i++){
      if (!next[i].image){
        const img = await resolveImageForCardId(next[i].id);
        if (img){ next[i] = { ...next[i], image: img }; changed = true; }
      }
    }
    if (changed){ await updateDoc(deckRef(), { cards: next, updated_at: serverTimestamp() }); }
  }, 250);
  function debounce(fn, wait=300){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), wait); }; }

  // ====== Actions (qty + thumbnails) ======
  async function addCard(id, name, qty, image){
    id = normalizeId(id);
    qty = Math.max(1, Number(qty||1));
    if(!id){ alert('Please enter a Card ID (e.g., sv4-123).'); return; }
    const cards = (currentDeck?.cards)||[];
    const idx = cards.findIndex(c=>c.id===id);
    if (idx>=0){
      const next = [...cards];
      next[idx] = { ...next[idx], qty: (Number(next[idx].qty||1) + qty), image: next[idx].image || image || '' };
      await updateDoc(deckRef(), { cards: next, updated_at: serverTimestamp() });
    } else {
      const next = [...cards, { id, name:(name||'').trim(), qty, image: image||'', added_at: new Date().toISOString() }];
      await updateDoc(deckRef(), { cards: next, updated_at: serverTimestamp() });
    }
    byId('cardId').value=''; byId('cardName').value=''; byId('qty').value='1';
  }

  async function changeQty(id, delta){
    id = normalizeId(id);
    const cards = (currentDeck?.cards)||[];
    const idx = cards.findIndex(c=>c.id===id);
    if (idx<0) return;
    const next = [...cards];
    const newQty = Math.max(0, Number(next[idx].qty||1) + delta);
    if (newQty===0){ next.splice(idx,1); }
    else { next[idx] = { ...next[idx], qty:newQty }; }
    await updateDoc(deckRef(), { cards: next, updated_at: serverTimestamp() });
  }

  async function removeCard(id){
    id = normalizeId(id || byId('cardId').value);
    const cards = (currentDeck?.cards)||[];
    const next = cards.filter(c=>c.id!==id);
    await updateDoc(deckRef(), { cards: next, updated_at: serverTimestamp() });
  }

  async function checkCard(id){
    id = normalizeId(id || byId('cardId').value);
    if(!id){ alert('Enter an ID to check.'); return; }
    const has = ((currentDeck?.cards)||[]).some(c=>c.id===id);
    alert(has ? `✅ Yes, ${id} is in this deck.` : `❌ No, ${id} is not in this deck.`);
  }

  function exportJson(){
    const data = { deck: slug, cards: (currentDeck?.cards)||[], updated_at: currentDeck?.updated_at || null };
    return JSON.stringify(data, null, 2);
  }

  function download(filename, text){
    const a = document.createElement('a');
    a.href = 'data:application/json;charset=utf-8,' + encodeURIComponent(text);
    a.download = filename; document.body.appendChild(a); a.click(); a.remove();
  }

  // ====== Wire up ======
  byId('createBtn').onclick = async ()=>{
    const id = crypto.randomUUID();
    setSlug(id);
    await setDoc(deckRef(), { cards: [], updated_at: serverTimestamp() });
    await subscribe();
  };

  byId('openExistingBtn').onclick = ()=>{
    const id = byId('existingId').value.trim();
    if (!id) return alert('Paste a deck UUID first.');
    setSlug(id);
    subscribe();
  };

  byId('addBtn').onclick = async () => {
    const id = byId('cardId').value;
    const name = byId('cardName').value;
    const qty = byId('qty').value;
    const img = await resolveImageForCardId(id);
    await addCard(id, name || '', qty, img);
  };
  byId('decreaseBtn').onclick = () => changeQty(byId('cardId').value, -1);
  byId('removeBtn').onclick = () => removeCard(byId('cardId').value);
  byId('checkBtn').onclick = () => checkCard(byId('cardId').value);

  byId('exportBtn').onclick = () => { byId('jsonArea').value = exportJson(); };
  byId('copyBtn').onclick = async () => { const t = exportJson(); byId('jsonArea').value=t; try{ await navigator.clipboard.writeText(t); alert('Copied!'); }catch{} };
  byId('downloadBtn').onclick = () => download(`deck-${slug}.json`, exportJson());

  byId('importBtn').onclick = async () => {
    try{
      const data = JSON.parse(byId('jsonArea').value);
      if(!data.cards || !Array.isArray(data.cards)) throw new Error('Invalid JSON: missing "cards" array.');
      await updateDoc(deckRef(), { cards: data.cards.map(c=>({ id: normalizeId(c.id), name:(c.name||'').trim(), qty: Math.max(1, Number(c.qty||1)), image: c.image||'', added_at: c.added_at || new Date().toISOString() })), updated_at: serverTimestamp() });
      alert('Imported!');
    }catch(e){ alert('Import failed: ' + e.message); }
  };

  byId('clearBtn').onclick = async () => {
    if(confirm('Clear all cards in this deck?')){
      await updateDoc(deckRef(), { cards: [], updated_at: serverTimestamp() });
    }
  };

  byId('copyUrlBtn').onclick = async () => {
    try { await navigator.clipboard.writeText(deckUrlInput.value); alert('Deck URL copied!'); } catch { /* ignore */ }
  };

  // ====== Search (click or Enter) with cancel ======
  let searchController = null; // AbortController to cancel in-flight search

  async function searchCardsByName(name, signal){
    const key = name.toLowerCase().trim();
    if (searchCache.has(key)) return searchCache.get(key);
    const q = encodeURIComponent(`name:"${name}"`);
    const url = `https://api.pokemontcg.io/v2/cards?q=${q}&pageSize=20`;
    const headers = POKETCG_KEY ? { 'X-Api-Key': POKETCG_KEY } : {};
    const res = await fetch(url, { headers, signal });
    if(!res.ok) throw new Error('Search failed');
    const json = await res.json();
    const data = json.data || [];
    searchCache.set(key, data);
    data.forEach(c=> idCache.set((c.id||'').toLowerCase(), c));
    return data;
  }

  async function doSearch(){
    const name = byId('searchName').value.trim();
    const results = byId('results');
    if(!name){ results.innerHTML = '<li class="muted">Type a name and press Search.</li>'; return; }

    if (searchController) searchController.abort();
    searchController = new AbortController();
    const { signal } = searchController;

    results.innerHTML = '<li class="muted">Searching…</li>';
    byId('searchBtn').disabled = true;
    try{
      const cards = await searchCardsByName(name, signal);
      results.innerHTML = '';
      if(cards.length===0){ results.innerHTML = '<li class="muted">No matches.</li>'; return; }
      cards.forEach(card=>{
        const id = (card.id || `${card.set?.id||'set'}-${card.number}`).toLowerCase();
        const li = document.createElement('li'); li.className='result';
        const img = document.createElement('img'); img.src = card.images?.small || ''; img.alt = card.name; img.loading='lazy'; img.decoding='async'; img.onerror=()=>{ img.style.display='none'; };
        const info = document.createElement('div');
        info.innerHTML = `<div><strong>${card.name}</strong> — ${card.set?.name||''} #${card.number} <span class="pill">${id}</span></div>`;
        const add = document.createElement('button'); add.textContent='Add'; add.className='btn'; add.onclick=()=> addCard(id, card.name, 1, card.images?.small || '');
        li.appendChild(img); li.appendChild(info); li.appendChild(add);
        results.appendChild(li);
      });
    }catch(e){
      if (e.name === 'AbortError') {
        // aborted: ignore
      } else {
        results.innerHTML = `<li class=\"muted\">Search error: ${e.message}</li>`;
      }
    } finally {
      byId('searchBtn').disabled = false;
    }
  }

  byId('searchBtn').onclick = doSearch;
  byId('searchName').addEventListener('keydown', (e)=>{
    if (e.key === 'Enter') { e.preventDefault(); doSearch(); }
  });

  // ====== Start if slug present ======
  if (slug) { subscribe(); }
</script>
</body>
</html>
